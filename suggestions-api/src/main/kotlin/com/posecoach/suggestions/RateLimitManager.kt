package com.posecoach.suggestions\n\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.sync.Mutex\nimport kotlinx.coroutines.sync.withLock\nimport timber.log.Timber\nimport java.util.concurrent.ConcurrentLinkedQueue\nimport kotlin.math.max\nimport kotlin.math.min\n\n/**\n * Advanced rate limiting and request throttling for Gemini API\n * Implements token bucket algorithm with burst capacity and adaptive backoff\n */\nclass RateLimitManager(\n    private val maxRequestsPerMinute: Int = 15, // Gemini free tier limit\n    private val maxRequestsPerDay: Int = 1500,   // Daily quota\n    private val burstCapacity: Int = 5,          // Allow short bursts\n    private val baseDelayMs: Long = 4000L        // Base delay between requests (4s)\n) {\n    \n    private val mutex = Mutex()\n    private val requestTimes = ConcurrentLinkedQueue<Long>()\n    private val dailyRequestTimes = ConcurrentLinkedQueue<Long>()\n    \n    // Adaptive backoff state\n    private var consecutiveFailures = 0\n    private var lastFailureTime = 0L\n    \n    companion object {\n        private const val MINUTE_MS = 60 * 1000L\n        private const val DAY_MS = 24 * 60 * 60 * 1000L\n        private const val MAX_BACKOFF_MS = 60 * 1000L // Maximum 1 minute backoff\n        private const val FAILURE_BACKOFF_MULTIPLIER = 2.0\n    }\n    \n    /**\n     * Check if a request can be made and potentially wait for rate limit\n     * @param waitIfLimited If true, will wait until request can be made\n     * @return true if request can proceed, false if rate limited and not waiting\n     */\n    suspend fun canMakeRequest(waitIfLimited: Boolean = true): Boolean {\n        return mutex.withLock {\n            val currentTime = System.currentTimeMillis()\n            \n            // Clean old request timestamps\n            cleanOldRequests(currentTime)\n            \n            // Check daily quota first\n            if (dailyRequestTimes.size >= maxRequestsPerDay) {\n                Timber.w(\"Daily API quota exceeded: ${dailyRequestTimes.size}/$maxRequestsPerDay\")\n                return@withLock false\n            }\n            \n            // Check minute-based rate limit\n            val recentRequests = requestTimes.size\n            val canProceed = recentRequests < maxRequestsPerMinute\n            \n            if (!canProceed && !waitIfLimited) {\n                Timber.d(\"Rate limited: $recentRequests/$maxRequestsPerMinute requests in last minute\")\n                return@withLock false\n            }\n            \n            // Calculate delay needed\n            val delayNeeded = calculateDelay(currentTime, recentRequests)\n            \n            if (delayNeeded > 0) {\n                Timber.d(\"Rate limiting: waiting ${delayNeeded}ms before request\")\n                delay(delayNeeded)\n            }\n            \n            // Record the request\n            recordRequest(currentTime + delayNeeded)\n            \n            true\n        }\n    }\n    \n    /**\n     * Record a successful request\n     */\n    suspend fun recordSuccess() {\n        mutex.withLock {\n            consecutiveFailures = 0\n            Timber.d(\"Request successful, reset failure counter\")\n        }\n    }\n    \n    /**\n     * Record a failed request and adjust backoff\n     */\n    suspend fun recordFailure(exception: Throwable) {\n        mutex.withLock {\n            consecutiveFailures++\n            lastFailureTime = System.currentTimeMillis()\n            \n            val isRateLimitError = exception.message?.contains(\"rate limit\", ignoreCase = true) == true ||\n                                  exception.message?.contains(\"quota\", ignoreCase = true) == true ||\n                                  exception.message?.contains(\"429\", ignoreCase = true) == true\n            \n            if (isRateLimitError) {\n                consecutiveFailures += 2 // Penalize rate limit errors more\n                Timber.w(\"Rate limit error detected, increasing backoff\")\n            }\n            \n            Timber.d(\"Request failed (attempt $consecutiveFailures): ${exception.message}\")\n        }\n    }\n    \n    /**\n     * Get current rate limit status\n     */\n    fun getRateLimitStatus(): RateLimitStatus {\n        val currentTime = System.currentTimeMillis()\n        cleanOldRequests(currentTime)\n        \n        val minuteRequests = requestTimes.size\n        val dailyRequests = dailyRequestTimes.size\n        \n        return RateLimitStatus(\n            requestsInLastMinute = minuteRequests,\n            maxRequestsPerMinute = maxRequestsPerMinute,\n            requestsToday = dailyRequests,\n            maxRequestsPerDay = maxRequestsPerDay,\n            consecutiveFailures = consecutiveFailures,\n            isLimited = minuteRequests >= maxRequestsPerMinute || dailyRequests >= maxRequestsPerDay\n        )\n    }\n    \n    private fun calculateDelay(currentTime: Long, recentRequests: Int): Long {\n        var delay = 0L\n        \n        // Base delay between requests\n        if (recentRequests > 0) {\n            delay = max(delay, baseDelayMs)\n        }\n        \n        // Burst capacity management\n        if (recentRequests >= burstCapacity) {\n            val burstPenalty = (recentRequests - burstCapacity + 1) * 1000L\n            delay = max(delay, burstPenalty)\n        }\n        \n        // Adaptive backoff for failures\n        if (consecutiveFailures > 0) {\n            val timeSinceFailure = currentTime - lastFailureTime\n            val backoffDelay = min(\n                (baseDelayMs * Math.pow(FAILURE_BACKOFF_MULTIPLIER, consecutiveFailures.toDouble())).toLong(),\n                MAX_BACKOFF_MS\n            )\n            \n            // Only apply backoff if recent failure\n            if (timeSinceFailure < backoffDelay) {\n                delay = max(delay, backoffDelay - timeSinceFailure)\n            }\n        }\n        \n        // Smooth out requests to avoid bunching\n        if (recentRequests > maxRequestsPerMinute / 2) {\n            val smoothingDelay = MINUTE_MS / maxRequestsPerMinute\n            delay = max(delay, smoothingDelay)\n        }\n        \n        return delay\n    }\n    \n    private fun recordRequest(timestamp: Long) {\n        requestTimes.offer(timestamp)\n        dailyRequestTimes.offer(timestamp)\n        \n        Timber.d(\"Request recorded at $timestamp\")\n    }\n    \n    private fun cleanOldRequests(currentTime: Long) {\n        // Remove requests older than 1 minute\n        while (requestTimes.peek()?.let { currentTime - it > MINUTE_MS } == true) {\n            requestTimes.poll()\n        }\n        \n        // Remove requests older than 1 day\n        while (dailyRequestTimes.peek()?.let { currentTime - it > DAY_MS } == true) {\n            dailyRequestTimes.poll()\n        }\n    }\n    \n    /**\n     * Reset all rate limiting state (for testing or configuration changes)\n     */\n    suspend fun reset() {\n        mutex.withLock {\n            requestTimes.clear()\n            dailyRequestTimes.clear()\n            consecutiveFailures = 0\n            lastFailureTime = 0L\n            Timber.d(\"Rate limiter reset\")\n        }\n    }\n}\n\ndata class RateLimitStatus(\n    val requestsInLastMinute: Int,\n    val maxRequestsPerMinute: Int,\n    val requestsToday: Int,\n    val maxRequestsPerDay: Int,\n    val consecutiveFailures: Int,\n    val isLimited: Boolean\n) {\n    val minuteUtilization: Float = requestsInLastMinute.toFloat() / maxRequestsPerMinute\n    val dailyUtilization: Float = requestsToday.toFloat() / maxRequestsPerDay\n    \n    fun canMakeRequest(): Boolean = !isLimited\n    \n    fun getNextAvailableSlot(): String {\n        return when {\n            requestsToday >= maxRequestsPerDay -> \"Tomorrow\"\n            requestsInLastMinute >= maxRequestsPerMinute -> \"Next minute\"\n            else -> \"Now\"\n        }\n    }\n}"